src/backend/replication/README

WALレシーバ - libpqWALレシーバ API
----------------------------------

プライマリサーバへの接続、WALファイルの受信、メッセージの送信を実施するWALレシーバによる、
通信の特徴的な部分はlibpqを用いたメインサーババイナリへのリンク保持を防ぐため動的にロードされます。
動的にロードされるモジュールは、ibpqwalreceiverディレクトリに存在します。

動的にロードされるモジュールには、4つの関数が実装されています。


bool walrcv_connect(char *conninfo, XLogRecPtr startpoint)

プライマリーサーバへの接続を確立し、'スタートポイント'からレプリケーションを開始します。
成功した場合、trueを返します。

bool walrcv_receive(int timeout, unsigned char *type, char **buffer, int *len)

接続を介して利用可能な任意のメッセージを取得し、'タイムアウト'(ms)の最大値をブロッキングします。
メッセージが正常に読み込まれた場合は、trueを返します。
それ以外の場合はfalseを返します。成功した場合、メッセージ・ペイロードへのポインタは、
*buffer、*lengthの長さ、および*typeにおいて受信したメッセージの種類に格納されます。
walrcv_*関数が次に呼ばれるまで、返されるbufferは有効なため、
呼び出し側はそれを解放を試みる必要がありません。

void walrcv_send(const char *buffer, int nbytes)

XLOGストリームにメッセージを送信します。

void walrcv_disconnect(void);

切断します。

このAPIは、現時点で内部検討すべきですが、
我々は将来的にはプラグイン可能なWALを受信するためのメソッドを可能にするサードパーティと
libpqwalreceiverを交換するため、オープンにしています。

Walレシーバ  IPC
---------------

スタートアッププロセスが実施するrestore_commandを利用した復旧がアーカイブWALの末端に達した際に、
WALを取得するwalレシーバプロセスは起動します。(ストリーミング・レプリケーションが設定された場合)

walレシーバプロセスは、postmasterのサブプロセスであるため、スタートアッププロセスがwalレシーバプロセスを直接フォークすることはできません。
その代わりに、postmasterにシグナルを送り、walレシーバプロセスの起動を求めます。
しかしその前に、スタートアッププロセスはWalRcvData->CONNINFOとWalRcvData->slotnameに値を入れ、
WalRcvData->receiveStartに開始点を入れ、初期化します。

walレシーバはマスタサーバからWALを受け取り、ディスクに書き込み、フラッシュ(pg_xlogディレクトリ内に)する度に、
WalRcvData-> receivedUptoを更新し、WAL再生をどこまで進めることができるのかをスタートアッププロセスに通知します。

指定された時間が経過または、新しいWAL書き込むもしくはフラッシュする度に、
Walレシーバはマスタサーバへレプリケーションの進行状況についての情報を送信します。
これは、報告目的で使用されます。

Walセンダ IPC
-------------

シャットダウン時、postmasterは通常のバックエンドとは異なる処理をwalセンダ―プロセスに対して実施します。
シャットダウン時のチェックポイントによる書き込みおよび、pgarchプロセスやその他の補助プロセスを停止する前に、
通常のバックエンドプロセスを停止さます。しかし、シャットダウン時のチェックポイントを含め、
すべてのWALをスタンバイサーバは受け取りたいため、マスタサーバシャットダウン前の停止は、
walsenderプロセスには望ましくありません。
したがって、postmasterはpgarchプロセスのようにwalセンダープロセスを扱い、
全ての通常のバックエンドが停止しcheckpointerがシャットダウンチェックポイントを発行した後、
PM_SHUTDOWN_2 フェーズで終了するように指示します。

postmasterが接続を受け付けると、postmasterは即座にハンドシェークや認証を処理するための新しいプロセスをフォークし、
プロセスはバックエンドになるために初期化を実行します。
postmasterは、その時点では通常のバックエンドプロセスになるのかwalセンダープロセスになるのかを知りません。
- 接続ハンドシェイクで示されます。
- postmasterがwalセンダープロセスと識別できるようにするには、いくつかの余分なシグナリングを必要とします。

walセンダープロセスは起動時に、walセンダープロセスとしてPMSignal配列内をマークします。
このように、postmasterに通常のバックエンドとは異なると伝えることができます。

postmasterがwalセンダープロセスを通常のバックエンドと認識していても大して害がないことに注意してください。
シャットダウンの早い段階でwalsenderを終了するのみです。
walセンダープロセスが初期化し、PMSignal配列内に自身をマークするまで、または、PMSignalスロットをアンマークし停止する場合は、
walセンダプロセスは、通常のバックエンドのように見えます。

各walsenderはWalSndCtl配列のエントリを割り当て、レプリケーションの進行状況についての情報を追跡します。
利用者は、統計ビューを介してそれらを監視することが可能です。

Walセンダー  walレシーバ プロトコル
--------------------------------

マニュアルをご参照下さい。